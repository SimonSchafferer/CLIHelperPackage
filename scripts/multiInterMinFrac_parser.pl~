#! /usr/bin/perl -w

use vars qw ($opt_o $opt_i);
use Getopt::Std;
getopts ('o:i:');

unless ($opt_o  && $opt_i ) {
        print "\nUsage: multiIntersectParser.pl -o output_file -i input_bed_files\n";
        print "\nAll options:\n";
        print " -o [filename]     output filename (mandatory)\n";
	print " -i [string]       input bed files (mandatory)\n";
        die;
}

my $out_fn;
if ($opt_o) { $out_fn = $opt_o; }

my @inputBED;
if ($opt_i) { 
	push(@inputBED,$opt_i);
	push(@inputBED, @ARGV);	
 }

$min_coverage = scalar @inputBED;


foreach $bed (@inputBED) {
	push (@inputBEDplus, "$bed.plus");
	push (@inputBEDminus, "$bed.minus");
	open (PLUS, ">$bed.plus");
	open (MINUS, ">$bed.minus");
	open (BED, "sortBed -i $bed |");
	while (<BED>) {
		print PLUS if /\t\+/;
		print MINUS if /\t-/;
	}
	close BED;
	close MINUS;
	close PLUS;
}

@segments = intersect ("+", @inputBEDplus);
push (@segments, (intersect ("-", @inputBEDminus)));

open (TMP, ">$out_fn");
foreach (@segments) {
	print TMP;
}
close TMP;

#my $sortedFN = "${out_fn}.sorted";
my $sortedFN = $out_fn."sorted";

unless(open SORTED,'>', $sortedFN) {
       die "nUnable to open '$sortedFN'\n";
}

open (BED, "sortBed -i $out_fn |");
while (<BED>) {
	print SORTED;
}
close BED;
close SORTED;

unlink $out_fn;
rename $sortedFN, $out_fn;

#removing the files generated temporarily
unlink @inputBEDplus;
unlink @inputBEDminus;

sub intersect {
	my ($strand, @bed) = @_;
	my @segments = ();
	my $seg_start = 0;
	open (INTERSECT, "multiIntersectBed -cluster -i @bed |");
	my $counter = 1;
	while (<INTERSECT>) {
	#	print;
		chomp;
		@line = split (/\t/, $_);
		if($line[3] == $min_coverage){
			$seg_start = $line[1];
			$seg_end = $line[2];
			#$max_coverage = $line[3];
			$chr = $line[0];
			push (@segments, "$chr\t$seg_start\t$seg_end\t$counter\t0\t$strand\n");
		$counter++;
		}
	}
	close INTERSECT;
	return @segments;
}



